<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Werkzeug库简介]]></title>
    <url>%2F2017%2F06%2F05%2FWerkzeug%2F</url>
    <content type="text"><![CDATA[Werkzeug 库简介Werkzeug 并不是一个框架, 它是一个WSGI工具集的库, 你可以通过它来创建自己的框架或者应用, Werkzeug是非常灵活的, 希望这篇文章对你有所帮助. WSGI(Web Server Gateway Interface)是WEB服务器和web框架或web应用之间建立的一种简单通用的接口协议. Werkzeug遵循WSGI的规范, 下面是一个简单的例子:123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env python# coding: utf-8from werkzeug.wrappers import Request, Responsedef my_app_version1(environ, start_response): """ 在没有werkzeug的帮助的话, 使用WSGI实现一个简单Web看起来是这样的 :param environ: 包含了所有进来的信息 :param start_response: 用来表明收到一个响应 :return: """ query_string = environ.get('QUERY_STRING') name = 'Man' if query_string: name = query_string.split('=')[1] start_response('200 OK', [('Content-Type', 'text/plain')]) return 'Hello %s, This is My App Version 0.1' % namedef my_app_version2(environ, start_response): """ 使用了Werkzeug 所提供的Request和Response, 你就不需要自己去直接去处理提交上来的请求(request)和响应(response) :param environ: :param start_response: :return: """ request = Request(environ) response = Response('Hello %s, This is My App Version 0.2' % request.args.get('name', 'Man')) return response(environ, start_response)if __name__ == '__main__': from werkzeug.serving import run_simple run_simple('localhost', 5011, my_app_version1) # run_simple('localhost', 5012, my_app_version2) 用Werkzeug构建一个简单的应用12345678910111213141516171819202122232425262728class SimpleFlask(object): def __init__(self, name): self.name = name self.rv = Response def dispatch_request(self, request): return self.rv('Hello %s, This is SimpleFlask' % request.args.get('name', 'Man')) def wsgi_app(self, environ, start_reponse): request = Request(environ) response = self.dispatch_request(request) return response(environ, start_reponse) def __call__(self, environ, start_response): return self.wsgi_app(environ, start_response)def create_app(): app = SimpleFlask(__name__) return appif __name__ == '__main__': from werkzeug.serving import run_simple simple_app = create_app() run_simple('localhost', 5012, simple_app)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>重点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask学习笔记第一篇之上下文]]></title>
    <url>%2F2017%2F06%2F02%2Fflask_g_request%2F</url>
    <content type="text"><![CDATA[本文只是记录个人学习Flask上下文的一些理解. 关于上下文的理解和更多的信息, 可以参考最下方的参考文献!Flask 中有两种上下文 请求上下文和应用上下文. Werkzeug 实现的 Local Stack 和 Local Proxy在了解Flask 上下文之前, 必须得先了解Werkzeug.local.Local Werkzeug 实现了一个Local类, 类似于ThreadLocal. 首先我们看看ThreadLocal. ThreadLocal则是一种特殊的对象, 它的”状态”对线程隔离——也就是说每个线程对一个ThreadLocal对象的修改都不会影响其他线程. ThreadLocal的内部实现: 123456789101112131415161718192021class _local(object): """ Thread-local data """ def __delattr__(self, name): # real signature unknown; restored from __doc__ """ x.__delattr__('name') &lt;==&gt; del x.name """ pass def __getattribute__(self, name): # real signature unknown; restored from __doc__ """ x.__getattribute__('name') &lt;==&gt; x.name """ pass def __init__(self, *args, **kwargs): # real signature unknown pass @staticmethod # known case of __new__ def __new__(S, *more): # real signature unknown; restored from __doc__ """ T.__new__(S, ...) -&gt; a new object with type S, a subtype of T """ pass def __setattr__(self, name, value): # real signature unknown; restored from __doc__ """ x.__setattr__('name', value) &lt;==&gt; x.name = value """ pass ThreadLocal Demo: 123456789101112131415161718192021222324252627#!/usr/bin/env python# coding: utf-8import threadingthread_local = threading.local()thread_local.main_id = 0print thread_local.main_id # 主线程里面, 打印结果为0class AppThread(threading.Thread): num = 0 def set_num(self, num): self.num = num def run(self): thread_local.main_id = self.num print thread_local.main_id # 在这个线程里面, 修改mian_id值app_thread = AppThread()app_thread.set_num(4)app_thread.start()print thread_local.main_id # 主线程 main_id 没有改变 Werkzeug.local.Local类 Werkzeug.local.Local会在Greenlet可用的情况下优先使用Greenlet的ID而不是线程ID以支持Gevent或Eventlet的调度; ThreadLocal只支持多线程调度 Werkzeug.local.Local实现的release_local的方法, 可以被release_local函数释放掉当前线程下的状态, 源码中有Example 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def release_local(local): """Releases the contents of the local for the current context. This makes it possible to use locals without a manager. Example:: &gt;&gt;&gt; loc = Local() &gt;&gt;&gt; loc.foo = 42 &gt;&gt;&gt; release_local(loc) &gt;&gt;&gt; hasattr(loc, 'foo') False With this function one can release :class:`Local` objects as well as :class:`LocalStack` objects. However it is not possible to release data held by proxies that way, one always has to retain a reference to the underlying local object in order to be able to release it. .. versionadded:: 0.6.1 """ local.__release_local__()class Local(object): __slots__ = ('__storage__', '__ident_func__') def __init__(self): object.__setattr__(self, '__storage__', &#123;&#125;) object.__setattr__(self, '__ident_func__', get_ident) def __iter__(self): return iter(self.__storage__.items()) def __call__(self, proxy): """Create a proxy for a name.""" return LocalProxy(self, proxy) def __release_local__(self): self.__storage__.pop(self.__ident_func__(), None) def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; def __delattr__(self, name): try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) 接下来我们来看看Werkzeug实现的LocalStack 和 LocalProxy LocalStack是用Werkzeug.local.Local实现的stack结构, 实现了pop, push以及top(快速拿到栈顶元素)等方法, 这些所有的操作都只在本线程可见.LocaLStack也可以被release_local函数释放掉当前线程下的状态(它也实现了release_local方法)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class LocalStack(object): """This class works similar to a :class:`Local` but keeps a stack of objects instead. This is best explained with an example:: &gt;&gt;&gt; ls = LocalStack() &gt;&gt;&gt; ls.push(42) &gt;&gt;&gt; ls.top 42 &gt;&gt;&gt; ls.push(23) &gt;&gt;&gt; ls.top 23 &gt;&gt;&gt; ls.pop() 23 &gt;&gt;&gt; ls.top 42 They can be force released by using a :class:`LocalManager` or with the :func:`release_local` function but the correct way is to pop the item from the stack after using. When the stack is empty it will no longer be bound to the current context (and as such released). By calling the stack without arguments it returns a proxy that resolves to the topmost item on the stack. .. versionadded:: 0.6.1 """ def __init__(self): self._local = Local() def __release_local__(self): self._local.__release_local__() def _get__ident_func__(self): return self._local.__ident_func__ def _set__ident_func__(self, value): object.__setattr__(self._local, '__ident_func__', value) __ident_func__ = property(_get__ident_func__, _set__ident_func__) del _get__ident_func__, _set__ident_func__ def __call__(self): def _lookup(): rv = self.top if rv is None: raise RuntimeError('object unbound') return rv return LocalProxy(_lookup) def push(self, obj): """Pushes a new item to the stack""" rv = getattr(self._local, 'stack', None) if rv is None: self._local.stack = rv = [] rv.append(obj) return rv def pop(self): """Removes the topmost item from the stack, will return the old value or `None` if the stack was already empty. """ stack = getattr(self._local, 'stack', None) if stack is None: return None elif len(stack) == 1: release_local(self._local) return stack[-1] else: return stack.pop() @property def top(self): """The topmost item on the stack. If the stack is empty, `None` is returned. """ try: return self._local.stack[-1] except (AttributeError, IndexError): return None LocalProxy则是一个典型的代理模式实现, LocalProxy接受一个callable的参数(比如一个函数)和一个string(可选), 这个参数被调用后本身应该是一个Werkzeug.local.Locald对象.把这个对LocalProxy对象的所有操作, 包括属性访问, 方法调用, 甚至是二元操作都会转发到Werkzeug.local.Locald对象上, 并且设置这个这个对象的name=string 12345678910111213141516171819202122232425262728293031323334353637@implements_boolclass LocalProxy(object): """Acts as a proxy for a werkzeug local. Forwards all operations to a proxied object. The only operations not supported for forwarding are right handed operands and any kind of assignment. Example usage:: from werkzeug.local import Local l = Local() # these are proxies request = l('request') user = l('user') from werkzeug.local import LocalStack _response_local = LocalStack() # this is a proxy response = _response_local() Whenever something is bound to l.user / l.request the proxy objects will forward all operations. If no object is bound a :exc:`RuntimeError` will be raised. To create proxies to :class:`Local` or :class:`LocalStack` objects, call the object as shown above. If you want to have a proxy to an object looked up by a function, you can (as of Werkzeug 0.6.1) pass a function to the :class:`LocalProxy` constructor:: session = LocalProxy(lambda: get_current_request().session) .. versionchanged:: 0.6.1 The class can be instanciated with a callable as well now. """ wsgi_app 第一步：生成request请求对象和请求上下文环境 第二步：请求进入预处理，错误处理及请求转发到响应的过程 第三步：请求分发 dispatch_request 第四步：返回到wsgi_app内部 12345678910111213141516171819202122232425262728293031323334353637383940414243def wsgi_app(self, environ, start_response): """The actual WSGI application. This is not implemented in `__call__` so that middlewares can be applied without losing a reference to the class. So instead of doing this:: app = MyMiddleware(app) It's a better idea to do this instead:: app.wsgi_app = MyMiddleware(app.wsgi_app) Then you still have the original application object around and can continue to call methods on it. .. versionchanged:: 0.7 The behavior of the before and after request callbacks was changed under error conditions and a new callback was added that will always execute at the end of the request, independent on if an error occurred or not. See :ref:`callbacks-and-errors`. :param environ: a WSGI environment :param start_response: a callable accepting a status code, a list of headers and an optional exception context to start the response """ ctx = self.request_context(environ) ctx.push() error = None try: try: response = self.full_dispatch_request() except Exception as e: error = e response = self.make_response(self.handle_exception(e)) return response(environ, start_response) finally: if self.should_ignore_error(error): error = None ctx.auto_pop(error)def __call__(self, environ, start_response): """Shortcut for :attr:`wsgi_app`.""" return self.wsgi_app(environ, start_response) 应用上下文 AppContext应用上下文会在合适的时间创建和销毁, 它不会在线程中移动, 并且也不会在不同的请求之间共享, 所以它一般用来存储数据库连接信息或者别的东西的最佳位置.当app = Flask(__name__)构造出一个Flask App的时候, AppContext并不会自动推入到_app_ctx_stack中,如果你使用Flask-SQLAlchemy, 需要写一个离线脚本时候, 你就会知道这其中的坑(RuntimeError).解决的办法是: 在运行离线脚本之前, 先将App的AppContext PUSH到_app_ctx_stack中, ctx = app.app_context() ctx.push()但是当我们正常跑Flask服务的时候, 是不需要手动push. 推入部分的逻辑有这样一条：如果发现 _app_ctx_stack 为空，则隐式地推入一个AppContext。 12345678910111213141516171819flask.globals.pydef _lookup_app_object(name): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return getattr(top, name) def _find_app(): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return top.app_app_ctx_stack = LocalStack()current_app = LocalProxy(_find_app)g = LocalProxy(partial(_lookup_app_object, 'g')) 1234567891011121314151617class AppContext(object): """The application context binds an application object implicitly to the current thread or greenlet, similar to how the :class:`RequestContext` binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context. """ def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) self.g = app.app_ctx_globals_class() # Like request context, app contexts can be pushed multiple times # but there a basic "refcount" is enough to track them. self._refcnt = 0 请求上下文 RequestContextrequest和session都属于请求上下文request 针对的是http请求作为对象session 针对的是更多是用户信息作为对象 1234567891011def _lookup_req_object(name): top = _request_ctx_stack.top if top is None: raise RuntimeError(_request_ctx_err_msg) return getattr(top, name)_request_ctx_stack = LocalStack()request = LocalProxy(partial(_lookup_req_object, 'request'))session = LocalProxy(partial(_lookup_req_object, 'session')) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class RequestContext(object): """The request context contains all request relevant information. It is created at the beginning of the request and pushed to the `_request_ctx_stack` and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided. Do not attempt to use this class directly, instead use :meth:`~flask.Flask.test_request_context` and :meth:`~flask.Flask.request_context` to create this object. When the request context is popped, it will evaluate all the functions registered on the application for teardown execution (:meth:`~flask.Flask.teardown_request`). The request context is automatically popped at the end of the request for you. In debug mode the request context is kept around if exceptions happen so that interactive debuggers have a chance to introspect the data. With 0.4 this can also be forced for requests that did not fail and outside of ``DEBUG`` mode. By setting ``'flask._preserve_context'`` to ``True`` on the WSGI environment the context will not pop itself at the end of the request. This is used by the :meth:`~flask.Flask.test_client` for example to implement the deferred cleanup functionality. You might find this helpful for unittests where you need the information from the context local around for a little longer. Make sure to properly :meth:`~werkzeug.LocalStack.pop` the stack yourself in that situation, otherwise your unittests will leak memory. """ def __init__(self, app, environ, request=None): self.app = app if request is None: request = app.request_class(environ) self.request = request self.url_adapter = app.create_url_adapter(self.request) self.flashes = None self.session = None # Request contexts can be pushed multiple times and interleaved with # other request contexts. Now only if the last level is popped we # get rid of them. Additionally if an application context is missing # one is created implicitly so for each level we add this information self._implicit_app_ctx_stack = [] # indicator if the context was preserved. Next time another context # is pushed the preserved context is popped. self.preserved = False # remembers the exception for pop if there is one in case the context # preservation kicks in. self._preserved_exc = None # Functions that should be executed after the request on the response # object. These will be called before the regular "after_request" # functions. self._after_request_functions = [] self.match_request() 参考文献 Flask 应用上下文 Flask 请求上下文 Flask 的 Context 机制 Flask的Context(上下文)学习笔记 flask 源码解析：上下文]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>重点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的一些零散的知识点]]></title>
    <url>%2F2017%2F05%2F27%2Fhttp%2F</url>
    <content type="text"><![CDATA[请求方式根据HTTP标准, HTTP请求可以使用多种请求方法.HTTP1.0定义了三种请求方法: GET, POST 和 HEAD方法.HTTP1.1新增了五种请求方法: OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法. Get Post Put Delete Trace Connect Options Head Session 和 Cookie Session 在计算机中, 尤其是在网络应用中, 称为”会话控制”. session对象存储特定用户会话所需的属性及配置信息session是用于保持状态的基于Web服务器的方法. session允许通过将对象存储在Web服务器的内存中在整个用户会话过程中保持任何对象 Cookie 指某些网站为了辨别用户身份, 进行session跟踪而储存在用户本地终端上的数据; 在计算机中是个存储在浏览器目录中的文本文件, 它可以包含有关用户的信息. 比较 cookie数据存放在客户的浏览器上, session数据放在服务器上 cookie不是很安全, 别人可以分析存放在本地的cookie并进行cookie欺骗, 如果主要考虑到安全应当使用session session会在一定时间内保存在服务器上. 当访问增多, 会比较占用你服务器的性能, 如果主要考虑到减轻服务器性能方面, 应当使用cookie 不同浏览器对cookie处理是不一样的, 如果客户端禁止cookie, 则cookie不能建立 并且在客户端, 一个浏览器能创建的cookie数量最多为300个, 并且每个不能超过4KB, 每个Web站点能设置的cookie总数不能超过20个 状态码当浏览者访问一个网页时, 浏览者的浏览器会向网页所在服务器发出请求. 当浏览器接收并显示网页前,此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求.HTTP状态码的英文为HTTP Status Code. 1** – 信息, 服务器收到请求, 需要请求者继续执行操作 2** – 成功, 操作被成功接收并处理 3** – 重定向, 需要进一步的操作以完成请求 4** – 客户端错误, 请求包含语法错误或无法完成请求 5** – 服务器错误, 服务器在处理请求的过程中发生了错误]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>重点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 实现八大排序]]></title>
    <url>%2F2017%2F05%2F24%2Fpython_sort%2F</url>
    <content type="text"><![CDATA[排序算法 各种排序算法 各种排序算法比较 冒泡排序 基本思想: 在要排序的一组数中, 对当前还未排好序的范围内的全部数, 自上而下对相邻的两个数依次进行比较和调整, 让较大的数往下沉, 较小的往上冒.即:每当两相邻的数比较后发现它们的排序与排序要求相反时, 就将它们互换. 算法实现: 12345678def bubble_sort(seq): for i, item_i in enumerate(seq): for j, item_j in enumerate(seq): if item_j &gt; item_i: seq[i], seq[j] = seq[j], seq[i] return seqprint bubble_sort([3, 6, 3, 44, 55, 11]) 快速排序 基本思想: 通过一趟排序将要排序的数据分割成独立的两部分, 其中一部分的所有数据都比另外一部分的所有数据都要小,然后再按此方法对这两部分数据分别进行快速排序, 整个排序过程可以递归进行，以此达到整个数据变成有序序列. 算法实现: 12345678910111213141516171819def quick_sort(seq, start_i, end_j): start = start_i end = end_j if start &gt;= end: return seq start_item = seq[start] while start &lt; end: while start &lt; end and seq[end] &gt;= start_item: end -= 1 seq[start] = seq[end] while start &lt; end and seq[start] &lt;= start_item: start += 1 seq[end] = seq[start] seq[start] = start_item quick_sort(seq, start_i, start - 1) quick_sort(seq, end + 1, end_j) return seqprint quick_sort([3, 6, 3, 44, 55, 11], 0, 5) 简单选择排序 基本思想: 选择排序也是一种简单直观的排序算法.它的工作原理很容易理解:首先在未排序序列中找到最小（大）元素, 存放到排序序列的起始位置;然后,再从剩余未排序元素中继续寻找最小（大）元素, 放到已排序序列的末尾. 以此类推，直到所有元素均排序完毕. 算法实现: 12345678910111213def select_sort(seq): for i in xrange(len(seq)): min_item = seq[i] min_j = i for j, item in enumerate(seq[i:]): if item &lt;= min_item: min_item = item min_j = j if min_j + i != i: seq[min_j + i], seq[i] = seq[i], seq[min_j + i] return seqprint select_sort([3, 6, 3, 44, 55, 11]) 直接插入排序 基本思想: 从第一个元素开始, 该元素可以认为已经被排序取出下一个元素, 在已经排序的元素序列中从后向前扫描, 找到已排序的元素小于或者等于新元素的位置, 将新元素插入到该位置后重复以上步骤, 直到排序完成 算法实现: 123456789101112def insert_sort(seq): for i in range(1, len(seq)): if seq[i - 1] &gt; seq[i]: item = seq[i] index = i while index &gt; 0 and seq[index - 1] &gt; item: seq[index] = seq[index - 1] index -= 1 seq[index] = item return seqprint insert_sort([3, 6, 3, 44, 55, 11]) 希尔排序 基本思想: 时间复杂度: 算法实现: 123456789```##### 归并排序* 基本思想:* 时间复杂度:* 算法实现: 12345678##### 堆排序* 基本思想:* 时间复杂度:* 算法实现: 12345678##### 基数排序* 基本思想:* 时间复杂度:* 算法实现: ```]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>重点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python list的简单实现]]></title>
    <url>%2F2017%2F05%2F24%2Fmylist%2F</url>
    <content type="text"><![CDATA[Python list的简单实现 这里我主要实现了一下几个功能: append, pop, index, length写的比较乱思路上大致就是 设计每个节点的属性, 最简单的是每个几点只保存当前的值和指向下一个节点点指针, 我这里增加了当前节点的index, 以及指向前一个节点的指针 设计链表的操作, append, pop, index, length 可以在此基础上, 再实现insert, extend 等操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133 #!/usr/bin/env python# coding: utf-8class Node(object): def __init__(self, value, next_node=None, pre_node=None): self.value = value self.index = 0 self.next_node = next_node self.pre_node = pre_node def get_next_node(self): return self.next_node def set_next_node(self, new_node): self.next_node = new_node def get_pre_node(self): return self.pre_node def set_pre_node(self, pre_node): self.pre_node = pre_node def set_index(self, num): self.index = num def __str__(self): return str(self.value)class MyList(object): def __init__(self): self.start = Node self.head = None self.size = 0 def _current_node(self): if not self.head: current = None else: current = self.head while current.get_next_node(): current = current.get_next_node() return current def init_head(self): c = None index = 0 if self.start: c = self.start c.index = 0 while c.get_next_node(): c = c.next_node index += 1 c.index = index return c def append(self, item): node = Node(item) node.set_index(self.size) node.set_pre_node(self.head) current = self._current_node() if current: current.set_next_node(node) else: self.start = node self.head = node self.size += 1 return 0 def pop(self, index=None): if index &gt; self.size - 1 or index &lt; 0: return None elif index is None or index == self.size - 1: if not self.head: return None head = self.head self.head = head.get_pre_node() self.head.set_next_node(None) return head else: if self.start: c = self.index(index) c_next = c.get_next_node() c_pre = c.get_pre_node() if c_pre: c_pre.set_next_node(c_next) if c_next: c_next.set_pre_node(c_pre) self.head = self.init_head() return c else: return None def index(self, num): c = self.start if c.index == num: return c while c.get_next_node(): c = c.next_node if c.index == num: break return c @property def length(self): return self.size def __str__(self): string = '[' if self.start: string += str(self.start.value) c = self.start while c.get_next_node(): c = c.next_node string += ', ' + str(c.value) string += ']' return stringif __name__ == '__main__': l = MyList() l.append(9) l.append(10) l.append(90808098) l.append('asdjkad') l.append('ssss') print l, l.length print l.index(0) print l.pop(0)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>重点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql使用心得]]></title>
    <url>%2F2016%2F11%2F22%2Fmysql%2F</url>
    <content type="text"><![CDATA[MYSQLMySql是一个快速、多线程、多用户的SQL数据库服务器。几乎是免费的，支持正规的SQL查询语言和采用多种数据类型，能对数据进行各种详细的查询等。 Relational Database Management SystemDDL（Data Definition Language）CREATE、ALTER与DROP DML（Data Manipulation Language）插，删，改，排，检INSERT、DELETE、JOIN、SORT、SELECT 注意1.between and 的边界2.通配符：%和_3.limit + offset4.inner join 和 left join5.union 和 union all REDISMONGOSQLALCHEMY SQLAlchemy无法修改表结构，如果需要可以使用SQLAlchemy开发者开源的另外一个软件Alembic来完成 1.create_engineA.strategy.create的调用，而 strategy 就是 engine 的实现细节. strategy 可以在 create_engine 调用时通过 strategy 参数指定, 目前官方的支持有三种： plain, 默认的 threadlocal, 连接是线程局部的 mock, 所有的 SQL 语句的执行会使用指定的函数 B.1234- pool_size 连接数- max_overflow 最多多几个连接- pool_recycle 连接重置周期- pool_timeout 连接超时时间 123456789from sqlalchemy import create_enginedef f(sql,*args,**kargs): print sql, args, kargss= &apos;mysql://user:password@host:port/database?charset=utf-8&apos;engine = create_engine(s, strategy=&apos;mock&apos;, executor=f, echo=False, pool_size=10, max_overflow=5, pool_recycle=3600, pool_timeout=30)print engine.execute(&apos;select id from &quot;user&quot;&apos;) 2. tableSQLAlchemy的DelarativeA.SQLAlchemy使用 Classic和Modern两种模式 来描述一个表。 Classic1234567891011121314151617181920from sqlalchemy import Column, Integer, MetaData, String, Tablefrom sqlalchemy.orm import mappermetadata = MetaData()user = Table(&apos;users&apos;, metadata, Column(&apos;id&apos;, Integer, primary_key=True), Column(&apos;name&apos;, String(50)), Column(&apos;fullname&apos;, String(50)), Column(&apos;password&apos;, String(12)) )class User(object): def __init__(self, name, fullname, password): self.name = name self.fullname = fullname self.password = passwordmapper(User, user) Modern123456789101112131415161718192021from sqlalchemy import Column, Integer, MetaData, Stringfrom sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()class User(Base): __tablename__ = &apos;user&apos; id = Column(Integer, primary_key=True) name = Column(String(50)) fullname = Column(String(50)) password = Column(String(12)) def __init__(self, name, fullname, password): self.name = name self.fullname = fullname self.password = password def __repr__(self): return &quot;&lt;User(&apos;%s&apos;,&apos;%s&apos;, &apos;%s&apos;)&gt;&quot; % (self.name, self.fullname, self.password)user = User() ORM会为所有被映射的表列创建类属性，这些属性是通过Python语言中python描述符机制来实现的。SQLAlchemy 的连接创建是 Lazy 的方式。要对对象实行持久化(Persist) (所谓的持久化就是把对象数据按照映射关系存储入数据库里) 3.sessionORM的操作句柄(Handle)被称为会话(Session)。 1234567891011from contextlib import closingfrom sqlalchemy.orm import sessionmakerSession = sessionmaker()Session.configure(bind=engine, autocommit=False, expire_on_commit=True)with closing(Session()) as session: user = User() user.name = &apos;test&apos; session.add(user) session.commit()]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>重点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python使用PIL破解验证码]]></title>
    <url>%2F2016%2F11%2F18%2Fpython_image%2F</url>
    <content type="text"><![CDATA[破解验证码DEMO本文原项目地址为破解验证码，刷新请求不同的验证码，后台破解验证码同时把结果返回。 主要破解代码段12345678910111213141516171819202122232425262728293031323334353637def break_image(image): &quot;&quot;&quot; 先把图片根据字符和空白RGB值，把图片转换成model=1的灰度模式 然后根据灰度模式，黑的为0， 白的为1，把图片转换成0，1字符串 &quot;&quot;&quot; image = image.convert(&quot;RGB&quot;) image2_dict = &#123;&#125; word_count = 4 # 观察验证码字符个数 start = 4 # 观察图片验证码开始的位置 one_word_length = 12 # 观察图片验证码每个字符是多少长度 i = 0 while i &lt; word_count: image2 = Image.new(&quot;1&quot;, (one_word_length, image.size[1]), 255) for x in range(start, start + one_word_length): for y in range(image.size[1]): pix = image.getpixel((x, y)) if pix[1] &lt; 255: # 根据图片验证码上面字符的颜色筛选 image2.putpixel((x - start, y), 0) image2_dict[i] = image2 start += one_word_length i += 1 tem_dict = &#123;&#125; for key in image2_dict.keys(): tem_list = [] for x in range(image2_dict.get(key).size[0]): tem_str = &apos;&apos; for y in range(image2_dict.get(key).size[1]): pix = image2_dict.get(key).getpixel((x, y)) if pix != 0: pix = 1 else: pix = 0 tem_str += str(pix) tem_list.append(tem_str + &quot;\n&quot;) tem_dict[key] = tem_list return tem_dict, image.size[1]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>重点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[index]]></title>
    <url>%2F2016%2F09%2F18%2Findex%2F</url>
    <content type="text"><![CDATA[SimpleHttpServer 简单文件传输 python -m SimpleHTTPServer 执行这个命令，就会在当前目录先启动一个简单的httpserver，在其他的服务器上通过ip+8000端口就可以下载到开启httpserver的服务器上当前目录下的文件,例如我在192.168.1.2的服务器上 1234▸ captcha_crack/▾ data/ simplehttpserver.txt test.py data目录下执行python -m SimpleHTTPServer在另外一台服务器shell下执行wget 192.168.1.2:8000/test.py就可以把test.py下载下来 Nohup 后台执行任务1nohup python test.py &amp; 像上面这样运行test.py脚本，这个进程会切换后台，即使在你的登录端退出，这个进程也会继续执行。 Supervisor 进程管理ubuntu下安装1apt-get install supervisor 为自己的进程配置一个conf文件，放在/etc/supervisor/conf.d/文件后缀为.conf -creload```12345678910111213让你的配置文件生效(这里比较暴力，重新载入了supervisor的所有配置，更多方法前往[supervisor](http://supervisord.org/))### Tmux 终端控制台+ 窗口+ 窗格+ 会话 想了解更多情前往[tmux](http://tmux.github.io/)### Ssh 远程登录* 创建key ssh-keygen -t rsa -C ‘your word’``` 想了解更多请前往ssh中文手册]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>普通</tag>
      </tags>
  </entry>
</search>